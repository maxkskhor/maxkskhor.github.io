---
layout: post
title: "A Simple Illustration of Exploration vs. Exploitation"
date: 2024-12-08 21:18:00 +0000
categories: python notes
permalink: /notes/general/explore-exploit
---

## A Simple Illustration

Have you ever wondered if you have chosen the best flat to rent, the right person to date or some decisions you made are optimal? How do you maximise your chance of getting the **best** option?

The truth is, under certain conditions, there is indeed a solution to maximise your chance of making the best decision.

Assume you are trying to find a personal assistant.
Let's assume that you can no longer go back to your previous option if you chose not to take this candidate.

Probably the most obvious strategy is:
- Look at the first few candidates and judge how well those candidates are to have a 'sense' of the qualities of those candidates,
- And then choose the one that is better than all the previous candidates you have looked at.

Let's call this the **explore-then-find-best** strategy.

We do not want to stop looking too early, as we might have not seen enough candidates and stuck with poor candidate. We also do not want to choose too late as the best candidate may have already been skipped.

The question is: when do we stop looking, and start choosing a candidate?

Let's formulate the problem mathematically.

### Objective
Find out the optimal number `h` of an explore-then-find-best strategy that maximises the chance of finding the best candidate. Notice the key here is the *best* candidate.

We can write a simple Python program to investigate this optimisation problem.

The Python program simulates the experiment `N` times for each value `h` and the plot is shown below.

{% highlight python %}
import random
import matplotlib.pyplot as plt

# Objective: Find out the optimal number h of an explore-exploit strategy
# that maximises the chance of finding the *best* candidate

# a list of numbers from 1 to 100
# assume 100 is the best candidate, 1 is the worst
seq = [i for i in range(1, 101)]


def run_experiment(N: int = 1000):
    res = {}
    for stop in range(1, 101):
        res[stop] = 0
        # run the experiment N times
        for _ in range(N):
            # shuffle the list in place
            random.shuffle(seq)
            highest_num_so_far = max(seq[:stop + 1])
            candidate_chosen = seq[-1]
            for current_candidate in seq[stop + 1:]:
                # if the current candidate is better than all the previous candidates
                # we will choose him/her
                if current_candidate > highest_num_so_far:
                    candidate_chosen = current_candidate
                    break
            # add one to counter if candidate chosen is the best (100)
            if candidate_chosen == 100:
                res[stop] += 1
    
    for i in res:
        res[i] /= N
    return res


if __name__ == '__main__':
    n = 50000
    res = run_experiment(n)
    plt.plot(res.keys(), res.values())
    plt.title(f'Run Experiment {n} times')
    plt.ylabel('Probability of getting best candidate')
    plt.xlabel('Exploration stopping point')
    plt.show()

{% endhighlight %}

Running the experiment 1000, 10000 and 50000 times gives us:

<div style="display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap;">
  <img src="{{ site.baseurl }}/assets/images/explore1.png" alt="Alt Text" style="width:80%;">
</div>

<div style="display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap;">
  <img src="{{ site.baseurl }}/assets/images/explore2.png" alt="Alt Text" style="width:80%;">
</div>

<div style="display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap;">
  <img src="{{ site.baseurl }}/assets/images/explore3.png" alt="Alt Text" style="width:80%;">
</div>

The optimal number is somewhere around 30. 

### Next step
What is the exact number and how can we prove it mathematically?
